local Security = {}

-- I chose to employ a custom algorithm because in some situations including a data card was not an option
-- This is secure enough for network traffic within the game

local bit = bit32

Security.loadedData = {
	Users = {}; -- Format: UserID = {id = "UserId", name = "name", group = "GroupName", c0 = "code0", c1 = "code1", limited(boolean), uses(number), disk = "address"}
	Groups = { -- Format: GroupName = {"GroupName" (string), accessLevel (number), [Inheritence (string)]} Level 0 is unrestricted access
		Admin = {"Admin", 0}; -- Lower number = higher access level
		Public = {"Public", 1000};
		Members = {"Members", 900, "Public"}; -- Groups employ single-level inheritence
	};
}

Security.currentUser = {}

Security.sessions = {}
--[[
Sesssion Format
SessionID = {
	SessionID = string
	UserID = string
	Authenticated = boolean
	Timeout = number
}
--]]
Security.chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
Security.numChars = Security.chars:len()
Security.charMap = {}

Security.dialSeed = 1297463248 -- DO NOT CHANGE THIS EVER
Security.numDials = 4 -- OR THIS

Security.dials = {}

Security.diskFormat = { -- The positions and bitlengths for the User disks
	[1] = {"id", 32, "string"};
	[2] = {"name", 32, "string"};
	[3] = {"c0", 16, "string"};
	[4] = {"c1", 16, "string"};
	[5] = {"session", 32, "string"};
}

for i=1,#Security.chars do
	Security.charMap[Security.chars:sub(i,i)] = i
end

Security.timeInterval = 30

Security.numChar = function(n) return Security.chars:sub(n,n) end
Security.charNum = function(c) return Security.charMap[c] end

Security.init = function()
	-- generate virtual dials
	local prng = Security.newRandom(Security.dialSeed)
	--print(Security.chars)
	--[[for i=1,Security.numDials do
		Security.genDial(i, prng)
	end-]]
	
	fs.uDrive.formats["1"] = Security.diskFormat -- Add the User ID disk format to the unmanaged disk library
	
	--local key = "H"
	--print(Security.encrypt(Security.decrypt("Hi", key), key.."2"))
	Security.init = nil
end

Security.serverInit = function()
	if (not Security.loadedData.PublicUser) then
		Security.loadedData.PublicUser = Security.addUser("Public", "Public")
		--Shell.print("[Security] Created Public User")
	end
	--[[
	event.listen(Enum.Event.UDRIVEADD, function(_,address)
		local usr = Security.loadedData.Users[Security.loadedData.PublicUser]
		if (not usr) then print("UsrErr") return end
		print(tostring(fs.uDrive.write(address, usr, 1)))
		local rd = fs.uDrive.read(address)
		for i,p in pairs(rd) do print(i.." : "..p) end
	end)--]]
	
	--event.timer(5, Security.sessionTick, math.huge)
	
end

Security.sessionTick = function()
	for i,p in pairs(Security.sessions) do
		
	end
end

Security.replaceStr = function(s, p, r)
    return table.concat{s:sub(1,p-1), r, s:sub(p+1)}
end

Security.genDial = function(dnum, prng)
	local dialChars = Security.chars
	local revDialChars = Security.chars
	for i=1,128 do
		local sw1 = prng:NextInt(1,Security.numChars)
		local sw2 = prng:NextInt(1,Security.numChars)
		local c1 = dialChars:sub(sw1, sw1)
		local c2 = dialChars:sub(sw2, sw2)
		dialChars = Security.replaceStr(dialChars, sw1, c2)
		dialChars = Security.replaceStr(dialChars, sw2, c1)
	end
	for i=1,128 do
		local sw1 = prng:NextInt(1,Security.numChars)
		local sw2 = prng:NextInt(1,Security.numChars)
		local c1 = revDialChars:sub(sw1, sw1)
		local c2 = revDialChars:sub(sw2, sw2)
		revDialChars = Security.replaceStr(revDialChars, sw1, c2)
		revDialChars = Security.replaceStr(revDialChars, sw2, c1)
	end
	Security.dials[dnum] = {dialChars, revDialChars}
	--print(dialChars)
	--print(revDialChars)
end

Security.rotDialStr = function(dialStr, dist)
	dist = dist-1
	return table.concat({dialStr:sub(dialStr:len()-dist), dialStr:sub(1,dialStr:len()-(dist+1))})
end

Security.rotDial = function(dial, dist)
	if (dist <= 0) then return end
	dial[1] = Security.rotDialStr(dial[1], dist)
	dial[2] = Security.rotDialStr(dial[2], dist)
end

Security.newDialset = function(settings)
	local dialSet = {}
	for i=1,#Security.dials do
		dialSet[i] = {Security.dials[i][1], Security.dials[i][2]}
	end
	for i,p in pairs(dialSet) do
		if (settings[i] > 0) then
			Security.rotDial(p, settings[i])
		end
	end
	return dialSet
end

Security.thruDial = function(dial, inPos, rev)
	local outPos
	if (rev) then
		local connectingLetter = dial[2]:sub(inPos,inPos)
		outPos,_ = dial[1]:find(connectingLetter)
	else
		local connectingLetter = dial[1]:sub(inPos,inPos)
		outPos,_ = dial[2]:find(connectingLetter)
	end
	return outPos
end

Security.thruAllDials = function(dialSet, pos, rev)
	if (rev) then
		for i=#dialSet,1,-1 do
			pos = Security.thruDial(dialSet[i], pos, rev)
		end
	else
		for i=1,#dialSet do
			pos = Security.thruDial(dialSet[i], pos, rev)
		end
	end
	return pos
end

Security.getSettings = function(key)
	if (not key) or (key == "") then return {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0} end
	local t = {}
	for i=1,Security.numDials do
		local n = (i <= key:len()) and Security.charNum(key:sub(i,i)) or 1
		t[i] = (n) and n-1 or 0
	end
	return t
end

Security.encrypt = function(str, key)
	local settings = Security.getSettings(key)
	local r = 1
	local dialSet = Security.newDialset(settings)
	local newStr = ""
	local islp = 0
	for i=1,str:len() do
		islp = islp + 1
		if (islp >= 500) then islp = 0 OS.sleep(0.05) end
		newStr = newStr..Security.numChar(Security.thruAllDials(dialSet, Security.charNum(str:sub(i,i)), false))
		Security.rotDial(dialSet[r], 1)
		r = r + 1
		if (r > #dialSet) then r = 1 end
	end
	return newStr
end

Security.decrypt = function(str, key)
	local settings = Security.getSettings(key)
	local r = 1
	local dialSet = Security.newDialset(settings)
	local newStr = ""
	local islp = 0
	for i=1,str:len() do
		islp = islp + 1
		if (islp >= 500) then islp = 0 OS.sleep(0.05) end
		newStr = newStr..Security.numChar(Security.thruAllDials(dialSet, Security.charNum(str:sub(i,i)), true))
		Security.rotDial(dialSet[r], 1)
		r = r + 1
		if (r > #dialSet) then r = 1 end
	end
	return newStr
end

Security.loadData = function()
	local str = Packager.getFileString("/SecurityData")
	if (not str) then print("'/SecurityData' does not exist, creating new SecurityData file") return end
	Security.loadedData = serialization.unserialize(str) or Security.loadedData
	return true
end

Security.saveData = function()
	local str = serialization.serialize(Security.loadedData)
	local handle, reason = filesystem.open("/SecurityData", "w")
	if (not handle) then
		print("Unable to open file ".."/SecurityData".."("..reason..")")
		return false
	end
	filesystem.write(handle, str)
	filesystem.close(handle)
	return true
end

Security.uuid = function()
	local s = ""
	for i=1,32 do s = s..(Security.numChar(math.random(1,Security.numChars))) end
	return s
end

Security.newUserID = function()
	local id
	local continue = false
	repeat
		continue = false
		id = Security.uuid()
		for i,_ in pairs(Security.loadedData.Users) do
			if (i == id) then continue = true break end
		end
	until (not continue)
	return id
end

Security.newCode = function()
	local s = ""
	for i=1,16 do s = s..(Security.numChar(math.random(1,Security.numChars))) end
	return s
end

Security.addUser = function(name, group, uses)
	local id = Security.newUserID()
	local tbl = {
		id = id,
		name = name,
		group = group,
		limited = ((uses) and true or false),
		uses = ((uses) and uses or 0),
		c0 = Security.newCode(),
		c1 = Security.newCode()
	}
	Security.loadedData.Users[id] = tbl
	return id
end

Security.findUserByID = function(id) -- Accepts partial IDs
	for i,p in pairs(Security.loadedData.Users) do
		if (p.id:find(id)) then return p end
	end
end

Security.loadUserToDisk = function(diskAddr, usrID)
	local user = Security.findUserByID(usrID)
	if (not user) then return end
end

Security.authUser = function(session)
	
end













Security.newRandom = function(Seed)
	if (not Seed) then Seed = math.random(0,100000000) end
	return {
		seed = Seed;
		initSeed = Seed;

		Reset = function(this, nseed)
			if (nseed) then this.seed = nseed return end
			this.seed = this.initSeed;
		end;
		
		Duplicate = function(this)
			return Security.newRandom(this.initSeed)
		end;
		
		NextInt = function(this, mn, mx)
			local B = 2^31
			local k = math.floor( this.seed / 127773 ) % B
   			this.seed = ( 16807 * ( this.seed - (( k * 127773) % B ) ) % B )
    		this.seed = this.seed - (( 2836 * k) % B )
    		if this.seed < 0 then this.seed = ((this.seed + B - 1) % B ) end
		    local temp_rand = this.seed / ( B - 1 )
		    if mx then
		        return math.floor( mn + 0.5 + temp_rand * ( mx - mn ) )
		    elseif mn then
		        return math.floor( temp_rand * mx ) + 1
		    else
		        return math.floor(temp_rand)
		    end
		end;
		
		NextFloat = function(this, mn, mx)
			local B = 2^31
			local k = math.floor( this.seed / 127773 ) % B
   			this.seed = ( 16807 * ( this.seed - (( k * 127773) % B ) ) % B )
    		this.seed = this.seed - (( 2836 * k) % B )
    		if this.seed < 0 then this.seed = ((this.seed + B - 1) % B ) end
		    local temp_rand = this.seed / ( B - 1 )
		    if mx then
		        return mn + 0.5 + temp_rand * ( mx - mn )
		    elseif mn then
		        return temp_rand * mx + 1
		    else
		        return temp_rand
		    end
		end;
		
		Next = function(this)
			local B = 2^31
			local k = math.floor( this.seed / 127773 ) % B
   			this.seed = ( 16807 * ( this.seed - (( k * 127773) % B ) ) % B )
    		this.seed = this.seed - (( 2836 * k) % B )
    		if this.seed < 0 then this.seed = ((this.seed + B - 1) % B ) end
		    local rand = this.seed / ( B - 1 )
		    return rand
		end;
		
	}
end





















return Security
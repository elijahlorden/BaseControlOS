local Server = {}

Server.deviceList = {[network.acceptedServerName] = {Name = network.acceptedServerName, Type = "Server", Address = component.modem.address, Pinged = true}} -- Name = {Name = name, Type = driverName, ConnectionTime = 0, Address = address}

Server.lastPing = 0
Server.pingTimeout = 10

Server.connectBeep = 1500
Server.disconnectBeep = 300

--[[
	USER SECURITY PROTOCOL
	Server keeps a recond of all users and access groups on its local disk, in a file separate from its main configuration file
	Each user entry consists of an access group name and an OTC generator key
--]]

Server.init = function()
	Server.pingDevices()
	event.timer(40, Server.pingDevices, math.huge)
	network.registerNetworkListener(Server.networkListener)
	--event.listen("component_added", Server.diskAddedEvent)
	--event.listen("component_removed", onComponentRemoved)
	Security.serverInit()
end

Server.load = function(config)
	if (not config.GateRegistry) then config.GateRegistry = {} end
	config.Name = network.acceptedServerName
end

Server.setup = function()

end


Server.powerOff = function()

end

Server.registerCommands = function()
	Commands.registerCommand("listDevices", Server.listDeviceCmd , "Lists currently connected devices, add TypeFilter to filter devices by type", "[TypeFilter]")
	Commands.registerCommand("sendUpdate", Server.updateCmd , "Package OS currently installed on Server and send it to networked devices.", "[DeviceName]")
	Commands.registerCommand("ping", Server.pingCmd , "Ping network for active devices", "")
end

Server.pingCmd = function(response)
	response:print("Pinging network...")
	Server.pingDevices()
	return true, response
end

Server.updateCmd = function(response, deviceName)
	local cmdReceiver = deviceName or "All"
	response:print("Sending update packages to "..cmdReceiver)
	response:flush()
	local packagedOS = Packager.packageIntoTable()
	response:print("Serializing packaged OS")
	response:flush()
	OS.sleep(0.1)
	local serializedOS = JSON.encode(packagedOS)
	response:print("Writing packaged OS to temporary file")
	local tmpProxy = component.proxy(computer.getBootAddress())
	if (tmpProxy.exists("/tmp/out_UpdatePackage")) then tmpProxy.remove("/tmp/out_UpdatePackage") end
	local handle, reason = tmpProxy.open("/tmp/out_UpdatePackage", "w")
	if (not handle) then response:print("Error opening file ("..reason..")") return end
	tmpProxy.write(handle, serializedOS)
	tmpProxy.close(handle)
	response:print("Sending file via FTP")
	response:print(tmpProxy.size("/tmp/out_UpdatePackage").."b")
	response:flush()
	network.ftp.sendFile(tmpProxy, "/tmp/out_UpdatePackage", "UpdatePackage", cmdReceiver)
	response:print("Update distributed")
	return true
end

Server.listDeviceCmd = function(response, typeFilter)
	local filter = typeFilter or ""
	local str = ""
	response:print("Format: &#fFFA500&#{DeviceName : DeviceType}&#fFFFFFF&#")
	for i,p in pairs(Server.deviceList) do
		if (string.find(p.Type, filter)) then
			str = str.."{"..p.Name.." : "..p.Type.."} "
		end
	end
	response:print("&#fFFA500&#"..str.."&#fFFFFFF&#")
	response:flush()
	return true
end

Server.networkListener = function(_, localNetworkCard, remoteAddress, port, distance, packet)
	if (port ~= 0) and (port ~= Enum.Port.Keepalive) and (port ~= Enum.Port.Stargate) and (port ~= Enum.Port.General) then return end
	if (packet.Header ~= Enum.Header.SHUTDOWN) then
		if (Server.deviceList[packet.Sender] ~= nil) then
			Server.deviceList[packet.Sender].Pinged = true
			Server.deviceList[packet.Sender].Address = remoteAddress
			--Shell.print(packet.Sender.." Responded to network ping")
		else
			Server.deviceList[packet.Sender] = {Name = packet.Sender, Type = packet.SenderType, Address = remoteAddress, Pinged = true}
			Shell.print("Network Device "..packet.Sender.." ("..packet.SenderType..") Connected")
			computer.beep(Server.connectBeep)
		end
	end

	if (packet.Header == Enum.Header.SHUTDOWN) then
		if (Server.deviceList[packet.Sender] ~= nil) then
			Server.deviceList[packet.Sender] = nil
			Shell.print(packet.Sender.." Disconnected (Reason: Shutting Down)")
			computer.beep(Server.disconnectBeep)
		end
	elseif (packet.Header == Enum.Header.FETCHGATEREGISTRY) then
		if (not packet.Sender) then return end
		Shell.print("GateRegistry Fetch Request")
		local outPkt = {Header = "GateRegistryFetched", Registry = Device.currentConfig.GateRegistry, Receiver = packet.Sender}
		network.sendPacket(Enum.Port.StargateResponse, outPkt, false)
	elseif (packet.Header == Enum.Header.REGISTERGATE) then
		if (not packet.GateName) or (not packet.GateAddress) then return end
		Device.currentConfig.GateRegistry[packet.GateName] = packet.GateAddress
		Shell.print("Gate "..packet.GateName.." Registered to address "..packet.GateAddress)
		Server.sendGateRegistryBroadcast()
		Device.saveConfig()
	elseif (packet.Header == Enum.Header.UNREGISTERGATE) then
		if (not packet.GateName) then return end
		Device.currentConfig.GateRegistry[packet.GateName] = nil
		Shell.print("Gate "..packet.GateName.." Unregistered")
		Server.sendGateRegistryBroadcast()
		Device.saveConfig()
	end
end

Server.sendGateRegistryBroadcast = function()
	local outPkt = {Header = Enum.Header.GATEREGISTRYBROADCAST, Registry = Device.currentConfig.GateRegistry}
	network.sendPacket(Enum.Port.StargateResponse, outPkt, false)
	Shell.print("Broadcasted GateRegistry update")
end

Server.pingDevices = function()
	local outPkt = {Header = Enum.Header.SERVERPING, Registry = Device.currentConfig.GateRegistry}
	network.sendPacket(Enum.Port.Keepalive, outPkt, false)
	for i,p in pairs(Server.deviceList) do
		p.Pinged = false
	end
	--Shell.print("Pinging network...")
	event.timer(Server.pingTimeout, function()
		for i,p in pairs(Server.deviceList) do
			if (not p.Pinged) and (p.Name ~= network.acceptedServerName) then
				Shell.print(p.Name.." Disconnected (Reason: Timed Out)")
				computer.beep(Server.disconnectBeep)
				Server.deviceList[i] = nil
			end
		end
	end)
end



























return Server

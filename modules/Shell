Shell = {}

Shell.ShellBacklog = {{Type = "print", Text = formatLoadingHeader("Loading complete")}} -- {Type = "print", Text = " "}

Shell.promptOpen = false

Shell.prompt = ">>> "
Shell.history = {}

Shell.networkCommandBuffer = {}

Shell.backlogDebounce = false

Shell.print = function(str)
	table.insert(Shell.ShellBacklog, {Type = "print", Text = str})
end

Shell.printPaged = function(str)
	table.insert(Shell.ShellBacklog, {Type = "printPaged", Text = str})
end

Shell.stepInterval = 0.05
Shell.step = function()
	if (#Shell.ShellBacklog > 0) and (not Shell.promptOpen) then
		Shell.backlogDebounce = true
		repeat
			local p = Shell.ShellBacklog[1]
			if (p.Type == "print") then
				print(p.Text)
			elseif (p.Type == "printPaged") then
				printPaged(p.Text)
			end
			table.remove(Shell.ShellBacklog, 1)
		until (#Shell.ShellBacklog == 0) or (Shell.promptOpen)
		Shell.backlogDebounce = false
	end
end

Shell.stepNetCmds = function()
	for i,p in pairs(Shell.networkCommandBuffer) do
		p.timeout = p.timeout - 2
		if (p.timeout <= 0) then
			if (p.ack) then
				Shell.print(Formatters.formatError("Command '"..p.cmd.."' to "..p.receiver.." timed out"))
			else
				Shell.print(Formatters.formatError("Command '"..p.cmd.."' to "..p.receiver.." was not acknowledged"))
			end
			Shell.networkCommandBuffer[i] = nil
		end
		if (p.done) then Shell.networkCommandBuffer[i] = nil end
	end
end

Shell.init = function()
	event.listen("key_down", Shell.keyDownEventListener)
	network.registerNetworkListener(Shell.networkCommandResponseListener, "CommandResponseListener")
	event.timer(2, Shell.stepNetCmds, math.huge)
end

Shell.keyDownEventListener = function(event, address, key, code, plr)
	if (Shell.promptOpen) then return end
	Shell.promptOpen = true
	prints("\n&#f32CD32&#Local&#fFFFFFF&#"..Shell.prompt.."&#fADD8E6&#")
	local strIn = term.read(Shell.history):gsub("\n", "")
	prints("&#fFFFFFF&#")
	if (strIn == "") or (strIn == " ") then Shell.promptOpen = false return end
	local strTbl = text.split(strIn, " ")
	if (not strTbl) then Shell.promptOpen = false return end
	if (#strTbl < 1) then Shell.promptOpen = false return end
	if (Shell.networkCommand(strTbl)) then Shell.promptOpen = false return end
	local startText = strTbl[1]
	table.remove(strTbl, 1)
	local success, message = pcall(function() Commands.executeCommand(startText, nil, table.unpack(strTbl)) end)
	if (not success) then print(message) end
	Shell.promptOpen = false
end

Shell.networkCommand = function(tArgs)
	if (not string.find(tArgs[1], ":")) then return false end
	local arg1 = text.split(tArgs[1], ":")
	table.remove(tArgs, 1)
	if (#arg1 ~= 2) then return false end
	local devName = arg1[1]
	local devCmd = arg1[2]
	if (devName == "") or (devName == " ") or (devCmd == "") or (devCmd == " ") then return false end
	local id = OS.uuid()
	Shell.networkCommandBuffer[id] =  {
		id = id,
		cmd = devCmd,
		receiver = devName,
		timeout = 10,
		ack = false,
		done = false
	}
	local packet = {Header = Enum.Header.RUNCOMMAND, Receiver = devName, CommandStr = Shell.appendCmd(devCmd, tArgs), id = id}
	network.sendPacket(Enum.Port.Command, packet, false)
	return true
end

Shell.networkCommandResponseListener = function(_, localNetworkCard, remoteAddress, port, distance, packet)
	if (port ~= 0) and (port ~= Enum.Port.CommandResponse) and (port ~= Enum.Port.General) then return end
	if (packet.Header ~= Enum.Header.COMMANDRESPONSE) then return end
	local resType = packet.resType
	local id = packet.id
	local bufferEntry = Shell.networkCommandBuffer[id]
	if (not bufferEntry) then return end
	if (resType == Enum.ResType.ACK) then
		Shell.print(Formatters.formatNotification(bufferEntry.receiver.." acknowledged reception of command"))
		bufferEntry.timeout = 10
		bufferEntry.ack = true
	elseif (resType == Enum.ResType.KEEPALIVE) then
		bufferEntry.timeout = tonumber(packet.keepTime) or 10
	elseif (resType == Enum.ResType.FLUSH) then
		if (packet.flushData) then
			Shell.handleResponse(packet.flushData)
		end
		if (bufferEntry.timeout < 10) then bufferEntry.timeout = 10 end
	elseif (resType == Enum.ResType.SUCCESS) then
		Shell.print(Formatters.formatSuccess("Command '"..bufferEntry.cmd.."' to "..bufferEntry.receiver.." completed"))
		bufferEntry.done = true
	elseif (resType == Enum.ResType.FAILURE) then
		Shell.print(Formatters.formatError("Command '"..bufferEntry.cmd.."' to "..bufferEntry.receiver.." failed"))
		bufferEntry.done = true
	elseif (resType == Enum.ResType.BUSY) then
		Shell.print(Formatters.formatError(bufferEntry.receiver.." is busy"))
		bufferEntry.done = true
	end
end

Shell.handleResponse = function(data)
	for i=1,#data do
		if (data[i].Type ~= nil) then
			if (data[i].Type == "print") then
				Shell.print(data[i].text)
			elseif (data[i].Type == "printPaged") then
				Shell.printPaged(data[i].text)
			end
		end
	end
end

Shell.appendCmd = function(name, tbl)
	local str = name.." "
	for _,s in pairs(tbl) do
		str = str..s.." "
	end
	return str
end

return Shell
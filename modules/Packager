local Packager = {}

Packager.readWholeFile = function(path, proxy)
	if (not proxy) then proxy = filesystem end
	local handle, reason = proxy.open(path)
	if (not handle) then
		return false, "Unable to read file "..path.."("..reason..")"
	end
	local buffer = ""
	repeat
	local data, reason = proxy.read(handle, math.huge)
	if (not data) and (reason) then
		return false, "Unable to read file "..path.."("..reason..")"
    end
	buffer = buffer..(data or "")
	until not data
	proxy.close(handle)
	return true, buffer
end

Packager.writeWholeFile = function(proxy, path, str)
	local handle, reason = proxy.open(path, "w")
	if (not handle) then return false, reason end
	while (str:len() > 1000) do
		proxy.write(handle, str:sub(1,1000))
		str = str:sub(1001)
		OS.sleep(0.01)
	end
	proxy.write(handle, str)
	return true
end

Packager.joinList = function(list)
	local s = ""
	for _,p in pairs(list) do
		s = s..p
	end
	return s
end

Packager.wipeDriveForOSInstall = function(proxy, path)
	for _,f in pairs(proxy.list(path)) do
		if (f ~= "config") then
			proxy.remove(path..f)
		end
	end
end

Packager.doFileTree = function(proxy, current, callback) --Run a callback function recursively on every file in the directory tree
	for i,f in pairs(proxy.list(current)) do
		if (i ~= "n" and f ~= "tmp/") then
			if (proxy.isDirectory(f) ) then
				local s,r = callback(proxy, current..f, true)
				if (s ~= nil and not s) then return false, r end
				s,r = Packager.doFileTree(proxy, f, callback)
				if (s ~= nil and not s) then return false, r end
			else
				local s,r = callback(proxy, current..f)
				if (s ~= nil and not s) then return false, r end
			end
		end
	end
	return true
end

Packager.getPathFile = function(s)
	local _,_,f = s:find("/?([^/]*)$")
	return f
end

Packager.installToDrive = function(driveLetter)
	local localproxy = fs.drive.letterToProxy("A")
	if (not localproxy) then return false, "Local drive removed" end
	local proxy = fs.drive.letterToProxy(driveLetter)
	if (not proxy) then return false, "Drive does not exist" end
	Packager.wipeDriveForOSInstall(proxy, "")
	return Packager.doFileTree(localproxy, "", function(cproxy, f, isDir)
		if (isDir) then proxy.makeDirectory(f) return end
		local n = Packager.getPathFile(f)
		if (n == "config") then return end
		return Packager.copyFile(cproxy, proxy, f, f)
	end)
end

Packager.copyFile = function(srcProxy, destProxy, srcFile, destFile)
	local readSuccess, readResult = Packager.readWholeFile(srcFile, srcProxy)
	if (not readSuccess) then return false, readResult end
	writeSuccess, writeResult = Packager.writeWholeFile(destProxy, destFile, readResult)
	return writeSuccess, writeResult
end

Packager.installMiniAppToDrive = function(drive, appFile)
	local proxy = fs.drive.letterToProxy(drive)
	if (not proxy) then print("Drive does not exist") return false end
	return Packager.installMiniAppToDriveProxy(proxy, appFile)
end

Packager.installMiniAppToDriveProxy = function(proxy, appFile)
	if (not proxy) then Shell.print("Drive does not exist") return false end
	local localproxy = fs.drive.letterToProxy("A")
	if (not localproxy) then return false, "Local drive removed" end
	local s,r = Packager.wipeDriveForOSInstall(proxy, "/")
	if (not s) then return false, r end
	s,r = Packager.copyFile(localproxy, proxy, "/init.lua", "/init.lua")
	if (not s) then return false, r end
	s,r = Packager.copyFile(localproxy, proxy, "/CoreLibs.lua", "/CoreLibs.lua")
	if (not s) then return false, r end
	s,r = Packager.copyFile(localproxy, proxy, "/Keyboard.lua", "/Keyboard.lua")
	if (not s) then return false, r end
	s,r = Packager.copyFile(localproxy, proxy, appFile, "/OS.lua")
	if (not s) then return false, r end
	for f in filesystem.list("/modules/") do
		s,r = Packager.copyFile(localproxy, proxy, "/modules/"..f, "/"..f)
		if (not s) then return false, r end
	end
	return true
end



Packager.componentAdded = function(_, address, componentType)
	if (componentType == "filesystem") then
		local proxy = component.proxy(address)
		if (not proxy) then return end
		local label = proxy.getLabel()
		local splitLabel = text.split(label, ":")
		if (#splitLabel < 2) then return end
		if (splitLabel[1] == "ma") then
			local appName = splitLabel[2]
			if (Device.miniAppList[appName] ~= nil) then
				Shell.print("Auto-updating miniApp")
				Packager.installMiniAppToDriveProxy(proxy, "/miniapps/"..Device.miniAppList[appName].file)
			end
		end
	end
end

Packager.init = function()
	event.listen("component_added", Packager.componentAdded)
end



















return Packager
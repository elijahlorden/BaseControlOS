local Device = {}
Device.driverList = {
	Default = {Name = "Default", desc = "Default, no special function"};
	Server = {Name = "Server", desc = "Central control server for networked devices"};
	Tablet = {Name = "Tablet", desc = "Remote control terminal", file = "Tablet"};
	Fusion_Reactor = {Name = "Fusion_Reactor", desc = "Used to control the Mekanism Fusion Reactor"};
	Redstone = {Name = "Redstone", desc = "Used to control redstone"};
}

Device.miniAppList = {
	LRelay = {Name = "LRelay", desc = "Relay program for linked cards", file = "LinkedRelay"};
	GateCon = {Name = "GateCon", desc = "Used to control Stargates which are not connected to a full StattenOS network", file = "GateController"};
}

Device.currentConfig = {
	Name = computer.address():sub(1,8);
	Driver = "Default";
	Settings = {} -- Entry = Name = {Group = "group", Type = "string", Value = "default", Default = "default"}
}

Device.settingSubtypes = {
	component = "string", -- Format: OC component address
	range = "string", -- --Format: lower,upper
}

Device.settingUpdateListeners = {} -- Using custom event for this because the setting object needs to be passed by reference

Device.Driver = nil
Device.updateReceived = false
Device.updateFiles = {}
Device.updateDirectories = {}
Device.okToUpdate = false
Device.updating = false

Device.updatePackage = nil

Device.loadConfig = function()
	local str = Packager.getFileString("/config")
	if (not str) then print("'/config' does not exist, creating new configuration file") return end
	Device.currentConfig = serialization.unserialize(str) or Device.currentConfig
	if (not Device.currentConfig.Settings) then Device.currentConfig.Settings = {} end
	return true
end

Device.saveConfig = function()
	local str = serialization.serialize(Device.currentConfig)
	local handle, reason = filesystem.open("/config", "w")
	if (not handle) then
		print("Unable to open file ".."/config".."("..reason..")")
		return false
	end
	filesystem.write(handle, str)
	filesystem.close(handle)
	return true
end

Device.registerSettings = function(reg)
	reg("Device", {
		{"Test", "range", "null"};
	})
end

Device.getSetting = function(name)
	if (Device.currentConfig.Settings[name]) then
		return true, Device.currentConfig.Settings[name].Value
	end
	return false, nil
end

Device.getSettingObject = function(name)
	return Device.currentConfig.Settings[name]
end

Device.settingUpdatedFunc = function(_, name, setting)
	if (setting.Subtype == "component") then
		local realAddress = component.get(setting.Value)
		setting.Value = realAddress or "INVALID UUID"
	elseif (setting.Subtype == "range") then
		local s = setting.Value
		local comma = s:find(",")
		if (not comma) then setting.Value = "INVALID RANGE" setting.lower = nil setting.upper = nil return end
		local lowerv = tonumber(s:sub(1,comma-1))
		local upperv = tonumber(s:sub(comma+1))
		if (not lowerv or not upperv) then setting.Value = "INVALID RANGE" setting.lower = nil setting.upper = nil return end
		setting.lower = lowerv
		setting.upper = upperv
		print(name.." "..lowerv.." "..upperv)
	end
end

Device.registerSettingsFunc = function(groupName, tbl)
	for i,p in pairs(tbl) do
		if (p[1]) and (p[2]) and (p[3]) then --Name, Type, Default, Description
			local sName = groupName.."."..p[1]
			local exists, value = Device.getSetting(sName)
			if (exists) then
				Device.currentConfig.Settings[sName].Default = p[3]
			else
				local sType = (Device.settingSubtypes[p[2]:lower()]) and Device.settingSubtypes[p[2]:lower()] or p[2]:lower()
				Device.currentConfig.Settings[sName] = {
					Group = groupName,
					Type = sType:lower(),
					Value = p[3],
					Default = p[3],
					Subtype = p[2]:lower(),
					Desc = ((p[4]) and p[4] or "No description provided")
				}
			end
		end
	end
end

-- Returns: 0 = ok, 1 = setting does not exist, 2 = type mismatch
Device.setSetting = function(name, value)
	if (tonumber(value)) then value = tonumber(value) end
	if (Device.currentConfig.Settings[name]) then
		if (Device.currentConfig.Settings[name].Type:lower() == "string") then value = tostring(value) end 
		if (type(value):lower() == Device.currentConfig.Settings[name].Type:lower()) then
			Device.currentConfig.Settings[name].Value = value
			for _,f in pairs(Device.settingUpdateListeners) do f(Enum.Event.SETTINGUPDATED, name, Device.currentConfig.Settings[name]) end
			return 0, Device.currentConfig.Settings[name].Value
		else
			return 2, Device.currentConfig.Settings[name].Type:lower()
		end
	end
	return 1
end

Device.registerSettingListener = function(func)
	if (type(func) == "function") then table.insert(Device.settingUpdateListeners, func) end
end

Device.getSettingsList = function()
	local tbl = {}
	for i,p in pairs(Device.currentConfig.Settings) do
		if (not tbl[p.Group]) then tbl[p.Group] = {} end
		table.insert(tbl[p.Group], i:sub(p.Group:len()+2))
	end
	return tbl
end

Device.commandListener = function(_, localNetworkCard, remoteAddress, port, distance, packet)
	if (port ~= 0) and (port ~= Enum.Port.Command) and (port ~= Enum.Port.General) then return end
	if (packet.Header == Enum.Header.RUNCOMMAND) then
		if (Commands.busy) then Device.commandBusyResponse(packet) return end
		local cmd = tostring(packet.CommandStr) or ""
		Shell.print("\n&#f32CD32&#"..packet.Sender.."&#fFFFFFF&#"..Shell.prompt.."&#fADD8E6&#"..packet.CommandStr.."&#fFFFFFF&#")
		OS.sleep(0.1)
		local strTbl = text.split(cmd, " ")
		if (not strTbl) then Device.commandFailResponse(packet) return end
		if (#strTbl < 1) then Device.commandFailResponse(packet) return end
		local startText = strTbl[1]
		table.remove(strTbl, 1)
		local newStrTbl = {}
		for i,p in pairs(strTbl) do
			if (p ~= "") and (p ~= " ") and (p ~= nil) then
				table.insert(newStrTbl, p)
			end
		end
		local success, message = pcall(function() Commands.executeCommand(startText, packet, table.unpack(newStrTbl)) end)
		if (not success) then print(message) end
	end
end

Device.commandFailResponse = function(packet)
	local response = newResponse(packet)
	response:sendAck()
	response:sendFailure()
end

Device.commandBusyResponse = function(packet)
	local response = newResponse(packet)
	response:sendAck()
	response:sendBusy()
end

Device.updateListener = function(_, FileName, FilePath) -- FTP event Listener
	if (FileName == "UpdatePackage") then
		Shell.print("Received update package, run 'reboot' to install update and reboot")
		Device.updatePackage = FilePath
	end
end

Device.init = function()
	Device.loadConfig()
	print("Loading Device Driver '"..Device.currentConfig.Driver.."'")
	local driverPath = "/drivers/"..Device.currentConfig.Driver
	if (filesystem.exists(driverPath)) then
		Device.Driver = dofile(driverPath)
		if (Device.Driver) then
			Device.Driver.load(Device.currentConfig)
			if (Device.Driver.init) then Device.Driver.init() end
			if (Device.Driver.registerCommands) then Device.Driver.registerCommands() end
			if (Device.Driver.registerSettings) then Device.Driver.registerSettings(Device.registerSettingsFunc) end
			Device.saveConfig()
		else
			network.registerPingListener()
		end
	else
		network.registerPingListener()
	end
	Device.registerSettings(Device.registerSettingsFunc)
	Device.registerSettingListener(Device.settingUpdatedFunc)
	print("Device Name: "..Device.currentConfig.Name)
	network.registerNetworkListener(Device.commandListener)
	network.ftp.registerFtpListener(Device.updateListener)
	-- set label
	local dProxy = fs.drive.letterToProxy(initDrive)
	dProxy.setLabel(Device.currentConfig.Name)
	-- send notification to server
	network.sendKeepalivePacket()
end






































return Device

local network = {}

network.acceptedServerName = "Server"

network.deviceList = {}

network.listeners = {}

network.getModem = function()
	local modem = component.modem
	if (not modem) then print("No network card attached to device") end
	return modem or nil
end

network.sendToLinkedCards = function(packet, sender, receiver, uuid)
	local tunnels = component.list("tunnel", true) or {}
	for a,t in tunnels do
		local tc = component.proxy(a)
		tc.send(packet, sender, receiver, uuid)
	end
end

network.sendPacket = function(port, packet, wireless)
	local modem = network.getModem()
	if (not modem) then return false end
	if (modem.isWireless()) then if (wireless) then modem.setStrength(500) else modem.setStrength(0) end end
	local packetStr = network.formatPacket(packet, port)
	local uuid = OS.uuid()
	network.sendToLinkedCards(packetStr, packet.Sender, packet.Receiver, uuid)
	return modem.broadcast(port, packetStr, packet.Sender, packet.Receiver, uuid)
end


network.getPortName = function(portNum)
	for i,p in pairs(Enum.Port) do
		if (p == portNum) then return i end
	end
end

network.formatPacket = function(inpkt, port)
	if (Device) then
		inpkt.SenderType = Device.currentConfig.Driver
		inpkt.Sender = Device.currentConfig.Name
	end
	if (not inpkt.Receiver) then inpkt.Receiver = "All" end
	inpkt.PortName = network.getPortName(port)
	local packetStr = serialization.serialize(inpkt)
	return packetStr
end

network.openPort = function(port)
	local modem = network.getModem()
	if (not modem) then return false end
	--print("Opening port "..port)
	return modem.open(port)
end

network.closePort = function(port)
	local modem = network.getModem()
	if (not modem) then return false end
	return modem.close(port)
end

network.registerNetworkListener = function(callback, ports, headers)
	for pn=1,#ports do
		local port = ports[pn]
		for hn=1,#headers do
			local header = headers[hn]
			network.listeners[port] = network.listeners[port] or {}
			network.listeners[port][header] = network.listeners[port][header] or {}
			local exists = false
			for i,p in pairs(network.listeners[port][header]) do if (p == callback) then exists = true break end end
			if (not exists) then table.insert(network.listeners[port][header], callback) end
		end
	end
end

network.sendKeepalivePacket = function()
	local packet = {Header = Enum.Header.KEEPALIVE, Receiver = network.acceptedServerName}
	network.sendPacket(Enum.Port.Keepalive, packet, false)
end

network.sendShutdownPacket = function()
	local packet = {Header = Enum.Header.SHUTDOWN}
	network.sendPacket(Enum.Port.Keepalive, packet, false)
end

network.pingListener = function(_, localNetworkCard, remoteAddress, port, distance, packet)
	if (port ~= 0) and (port ~= Enum.Port.Keepalive) and (port ~= Enum.Port.General) then return end
	if (packet.Header ~= Enum.Header.SERVERPING) then return end
	network.sendKeepalivePacket()
end

network.registerPingListener = function()
	network.registerNetworkListener(network.pingListener, {Enum.Port.Keepalive, Enum.Port.General}, {Enum.Header.SERVERPING})
end

network.serverUpdateListener = function(_, localNetworkCard, remoteAddress, port, distance, packet) -- This keeps the local device list in sync with the master device list on the server
	if (port ~= Enum.Port.ServerInfo) then return end
	if (packet.Header == Enum.Header.RSTLOCALDEVICELIST) then -- Reset local device list
		network.deviceList = {}
	elseif (packet.Header == Enum.Header.SERVERDEVICELIST) then -- Add devices to local device list
		if (not packet.List) or (#mapToKeyPair(packet.List) < 1) then return end
		--for i,p in pairs(packet.List) do print(i) network.deviceList[i] = p end
	elseif (packet.Header == Enum.Header.NEWDEVICE) then -- Add a device to local device list
		if (not packet.NewDevice) then return end
		network.deviceList[packet.NewDevice.Name] = packet.NewDevice
	elseif (packet.Header == Enum.Header.DEVICEDISCONNECT) then -- Remove a device from local device list
		if (not packet.DeviceName) then return end
		network.deviceList[packet.DeviceName] = nil
	end
end

network.wrappedNetworkSignalGenerator = function(_, localNetworkCard, remoteAddress, port, distance, inpkt, sender, receiver, packetId)
	if (not Device) or (not Device.currentConfig) then return end
	if (Device.currentConfig.Driver ~= "Server") then if (not Device.currentConfig.ServerAddress) or (Device.currentConfig.ServerAddress == "") then return end end
	if (not port) or (not inpkt) or (type(inpkt) ~= "string") then return end
	local packet = serialization.unserialize(inpkt)
	if (not packet) then return end
	if (not packet.Header) or (not packet.Sender) or (not packet.Receiver) then return end
	if (packet.Receiver ~= Device.currentConfig.Name) and (packet.Receiver ~= "All") then return end
	--print("Header: "..packet.Header.." Port: "..tostring(port))
	if (port ~= Enum.Port.Tunnel) then -- Always trust traffic coming from a linked card
		local isServer = false
		if (packet.Sender == network.acceptedServerName) then -- Check for valid server
			isServer = true
			if (not remoteAddress:find(Device.currentConfig.ServerAddress)) then
				if (Shell) then
					Shell.print("Invalid server detected at "..remoteAddress)
				end
			end
		end
		if (not isServer) then
			if (Device.currentConfig.Driver == "Server") then -- The server uses the direct list of allowed network cards, while other devices use the list generated by the server
				local authed = false
				for i,p in pairs(network.deviceList) do
					if (p == remoteAddress) then authed = true break end
				end
				if (not authed) then computer.pushSignal(Enum.Event.UNAUTHNETWORKSIGNAL, remoteAddress) return end
			else
				local authed = false
				for i,p in pairs(network.deviceList) do
					if (p.Address == remoteAddress) then authed = true break end
				end
				if (not authed) then computer.pushSignal(Enum.Event.UNAUTHNETWORKSIGNAL, remoteAddress) return end
			end
		end
	end
	if (port == Enum.Port.Tunnel) then -- Transform the port if the packet came from a linked card
		port = Enum.Port[packet.PortName] or Enum.Port.General
	end
	--computer.pushSignal(Enum.Event.WRAPPEDNETWORKSIGNAL, localNetworkCard, remoteAddress, port, distance, packet)
	if (network.listeners[port][packet.Header]) then
		for _,f in pairs(network.listeners[port][packet.Header]) do
			local result, message = pcall(f, Enum.Event.WRAPPEDNETWORKSIGNAL, localNetworkCard, remoteAddress, port, distance, packet)
			if (not result) then
				Shell.print("Network listener error: "..message)
			end
		end
	end
end

network.init = function()
	network.portInit()
	network.portInit = nil
	
	event.listen("modem_message", network.wrappedNetworkSignalGenerator)
	network.registerNetworkListener(network.serverUpdateListener, {Enum.Port.ServerInfo}, {Enum.Header.RSTLOCALDEVICELIST, Enum.Header.SERVERDEVICELIST, Enum.Header.NEWDEVICE, Enum.Header.DEVICEDISCONNECT})
	network.registerNetworkListener(network.notifications.listener, {Enum.Port.Notifications, Enum.Port.General}, {Enum.Header.NOTIFICATION})
	network.registerNetworkListener(network.stream.streamListener, {Enum.Port.Stream}, {Enum.Header.STREAMOPEN, Enum.Header.STREAMCLOSE, Enum.Header.STREAMACK, Enum.Header.STREAMPING, Enum.Header.STREAMDATA, Enum.Header.STREAMERROR})
	
	event.timer(2, network.stream.streamUpdater, math.huge)
	event.timer(10, network.stream.streamPinger, math.huge)
	
	network.stream.registerTarget("test", network.stream.testTarget)
end

network.portInit = function()
	for i,p in pairs(Enum.Port) do
		if (p > 0 and p <= 65535) then
			local success = network.openPort(p)
			if (success) then
				--print("Opened "..i.." Port ("..p..")")
			else
				print("Unable to open "..i.." Port ("..p..")")
			end
		end
	end
end

------------------------------- NOTIFICATIONS MODULE -------------------------------

network.notifications = {}

network.notifications.broadcast = function(message)
	local packet = {Header = Enum.Header.NOTIFICATION, Message = message}
	network.sendPacket(Enum.Port.Notifications, packet, false)
end

network.notifications.listener = function(_, localNetworkCard, remoteAddress, port, distance, packet)
	if (port ~= 0) and (port ~= Enum.Port.Notifications) and (port ~= Enum.Port.General) then return end
	if (not packet) then return end
	if (packet.Header ~= Enum.Header.NOTIFICATION) then return end
	if (not packet.Message) then return end
	computer.beep(2000)
	Shell.print("&#fFFFF00&#[NOTIFICATION]&#fFFFF00&# "..packet.Message.."&#fFFFFFF&#")
	computer.beep(2000)
end

------------------------------- END NOTIFICATIONS MODULE -------------------------------



------------------------------- STREAMS MODULE -------------------------------
--[[
	Streams are a safe way of transferring data between computers
	Streams will ensure that a sent packet reaches it's destination, resending it if needed.  A stream will not allow you to send another packet until it has confirmed delivery of the last one.
	See the FTP code for an example of streams in action
--]]
network.stream = {}
network.stream.targets = {}
network.stream.streams = {}
network.stream.rStreams = {}

network.stream.streamFunctions = {
	close = function(this, reason)
		if (not network.stream.streams[this.id] or this.status == Enum.Stream.Opening or this.status == Enum.Stream.Closed) then return false end
		network.sendPacket(Enum.Port.Stream, {Header = Enum.Header.STREAMCLOSE, Receiver = this.receiver, sid = this.id, sreason = reason or "Stream closed by host"}, false)
		network.stream.streams[this.id] = nil
		return true
	end,
	
	send = function(this, data)
		if (not network.stream.streams[this.id] or this.status ~= Enum.Stream.Idle or type(data) ~= "table") then return false end
		this.lastPacketId = this.lastPacketId + 1
		this.lastData = data
		this.status = Enum.Stream.Streaming
		network.sendPacket(Enum.Port.Stream, {Header = Enum.Header.STREAMDATA, Receiver = this.receiver, sid = this.id, spid = this.lastPacketId, sdata = data}, false)
	end
}

network.stream.streamMeta = {__index = network.stream.streamFunctions}

network.stream.registerTarget = function(name, callback)
	network.stream.targets[name] = callback
end

network.stream.testTarget = function(e, stream, data, state)
	print("Target called "..e.." "..stream.id)
	if (e == Enum.Stream.DataEvent) then Shell.print(data[1]) end
end

--[[network.stream.sendPacket = function(fileName, receiver, chunk)
	local packet = {Header = Enum.Header.FILETRANSFERDATA, Receiver = receiver, FileName = fileName, Chunk = chunk}
	return network.sendPacket(Enum.Port.FTP, packet, false)
end--]]

network.stream.openStream = function(receiver, target, name)
	local stream = {
		status = Enum.Stream.Opening,
		receiver = receiver,
		pinging = true,
		timeout = 15,
		ackTimeout = 10,
		resendTries = 0,
		name = name,
		id = OS.uuid(),
		lastData = {},
		lastPacketId = -1,
		target = target,
		lastPing = computer.uptime(),
	}
	setmetatable(stream, network.stream.streamMeta)
	network.sendPacket(Enum.Port.Stream, {Header = Enum.Header.STREAMOPEN, Receiver = receiver, sid = stream.id, starget = target, sname = name})
	network.stream.streams[stream.id] = stream
	return stream
end

network.stream.streamListener = function(_, localNetworkCard, remoteAddress, port, distance, packet)
	if (port ~= Enum.Port.Stream) then return end
	if (packet.Header == Enum.Header.STREAMOPEN) then
		local target = network.stream.targets[packet.starget]
		local tbl = {
			id = packet.sid,
			name = packet.sname,
			timeout = 120,
			sender = packet.Sender,
			target = target,
			lastPacketId = -1,
			state = {}
		}
		if (not target) then network.sendPacket(Enum.Port.Stream, {Header = Enum.Header.STREAMERROR, Receiver = tbl.receiver, sid = tbl.id, sreason = "Invalid target"}, false) return end
		if (OS.debug) then Shell.print("New stream from "..tbl.sender.." name: "..tbl.name.." id: "..tbl.id) end
		network.sendPacket(Enum.Port.Stream, {Header = Enum.Header.STREAMACK, Receiver = tbl.sender, sid = tbl.id, spid = -1})
		network.stream.rStreams[tbl.id] = tbl
		local result, message = pcall(tbl.target, Enum.Stream.OpenEvent, tbl, nil, state)
		if (not result) then
			Shell.print("Target "..packet.starget.."threw error: "..message)
		end
	elseif (packet.Header == Enum.Header.STREAMCLOSE) then
		if (network.stream.rStreams[packet.sid]) then -- Receivers
			local stream = network.stream.rStreams[packet.sid]
			if (OS.debug) then Shell.print("Stream (receiver) "..stream.id.." closed, reason: "..packet.sreason) end
			local result, message = pcall(stream.target, Enum.Stream.CloseEvent, stream, packet.reason, state)
			if (not result) then
				Shell.print("Target "..packet.starget.."threw error: "..message)
			end
			network.stream.rStreams[packet.sid] = nil
		end
		if (network.stream.streams[packet.sid]) then -- Senders
			local stream = network.stream.streams[packet.sid]
			if (OS.debug) then Shell.print("Stream (sender) "..stream.id.." closed, reason: "..packet.sreason) end
			stream.status = Enum.Stream.Closed
			stream.reason = packet.sreason
			network.stream.streams[packet.sid] = nil
		end
	elseif (packet.Header == Enum.Header.STREAMERROR) then
		if (network.stream.streams[packet.sid]) then -- Senders
			local stream = network.stream.streams[packet.sid]
			if (OS.debug) then Shell.print("Stream (sender) targeting "..stream.target.." with id "..stream.id.." errored on remote machine: "..packet.sreason) end
			stream.status = Enum.Stream.Closed
			stream.reason = packet.sreason
			network.stream.streams[packet.sid] = nil
		end
		-- Ignore if receiver
	elseif (packet.Header == Enum.Header.STREAMACK) then
		if (network.stream.streams[packet.sid]) then -- Senders
			local stream = network.stream.streams[packet.sid]
			if (packet.spid == -1) then -- an id of -1 means it is a keepalive packet
				if (stream.status == Enum.Stream.Opening) then
					if (OS.debug) then Shell.print("Stream (sender) "..stream.target.." with id "..stream.id.." received confirmation of stream creation") end
					stream.status = Enum.Stream.Idle
					stream.pinging = false
					stream.timeout = 15
				else
					if (OS.debug) then Shell.print("Stream (sender) "..stream.target.." with id "..stream.id.." received keepalive") end
					stream.pinging = false
					stream.timeout = 15
				end
			elseif (packet.spid == stream.lastPacketId and stream.status == Enum.Stream.Streaming) then -- If the id matches the last packet id, it is an ack of packet reception
				stream.resendTries = 0
				stream.status = Enum.Stream.Idle
			end
		end
		-- Ignore if receiver
	elseif (packet.Header == Enum.Header.STREAMPING) then
		if (network.stream.rStreams[packet.sid]) then -- Receivers
			local stream = network.stream.rStreams[packet.sid]
			if (OS.debug) then Shell.print("Stream (receiver) "..stream.id.." pinged, sending ack") end
			network.sendPacket(Enum.Port.Stream, {Header = Enum.Header.STREAMACK, Receiver = stream.sender, sid = stream.id, spid = -1})
			stream.timeout = 120
		end
		-- Ignore if sender
	elseif (packet.Header == Enum.Header.STREAMDATA) then
		if (network.stream.rStreams[packet.sid]) then -- Receivers
			local stream = network.stream.rStreams[packet.sid]
			if (packet.spid > stream.lastPacketId) then
				stream.lastPacketId = packet.spid
				network.sendPacket(Enum.Port.Stream, {Header = Enum.Header.STREAMACK, Receiver = stream.sender, sid = stream.id, spid = packet.spid})
				if (OS.debug) then Shell.print("Stream (receiver) "..stream.id.." received data packet") end
				local result, message = pcall(stream.target, Enum.Stream.DataEvent, stream, packet.sdata, state)
				if (not result) then
					Shell.print("Target "..packet.starget.."threw error: "..message)
				end
			else
				if (OS.debug) then Shell.print("Stream (receiver) "..stream.id.." received an old packet, discarding") end
			end
		end
		-- Ignore if sender
	end
end

network.stream.streamUpdater = function()
	for i,p in pairs(network.stream.rStreams) do -- Stream Receivers
		p.timeout = p.timeout - 2
		if (p.timeout < 0) then
			if (OS.debug) then Shell.print("Stream (receiver) "..p.id.." timed out") end
			network.sendPacket(Enum.Port.Stream, {Header = Enum.Header.STREAMCLOSE, Receiver = p.sender, sid = p.id, sreason = "Timed out"}, false)
			network.stream.rStreams[i] = nil
		end
	end
	for i,p in pairs(network.stream.streams) do -- Stream Senders
		if (p.pinging) then
			p.timeout = p.timeout - 2
			if (p.timeout < 0) then
				if (OS.debug) then Shell.print("Stream (sender) "..p.id.." timed out") end
				p.status = Enum.Stream.Closed
				p.reason = "Timed out"
				network.sendPacket(Enum.Port.Stream, {Header = Enum.Header.STREAMCLOSE, Receiver = p.receiver, sid = p.id, sreason = "Timed out"}, false)
				network.stream.streams[i] = nil
				return
			end
		end
		if (p.status == Enum.Stream.Streaming) then
			p.ackTimeout = p.ackTimeout - 2
			if (p.ackTimeout < 0) then -- Re-send last data packet using last packet id
				network.sendPacket(Enum.Port.Stream, {Header = Enum.Header.STREAMDATA, Receiver = p.receiver, sid = p.id, spid = p.lastPacketId, sdata = p.lastData}, false)
				if (OS.debug) then Shell.print("Stream "..p.id.." is re-sending packet"..p.lastPacketId) end
				p.ackTimeout = 10
				p.resendTries = p.resendTries + 1
			end
		end
	end
end

network.stream._pingMap = nil
network.stream._pingIter = 0

network.stream.streamPinger = function() -- Ping streams one at a time to avoid taxing the network
	if (not network.stream._pingMap or network.stream._pingIter > #network.stream._pingMap)  then
		network.stream._pingMap = mapToKeyPair(network.stream.streams)
		network.stream._pingIter = 1
	end
	if (#network.stream._pingMap == 0) then return end
	local stream
	for i=1,math.ceil(#network.stream._pingMap/5) do
		repeat -- Go through the cached streams until an active one is found (will usually hit after the first iteration)
			stream = network.stream._pingMap[network.stream._pingIter]
			network.stream._pingIter = network.stream._pingIter + 1
		until (not stream) or (network.stream.streams[stream.id])
		if (stream and not stream.pinging and (computer.uptime() - stream.lastPing) >= 15) then
			if (OS.debug) then Shell.print("Stream "..stream.id.." is pinging receiver") end
			network.sendPacket(Enum.Port.Stream, {Header = Enum.Header.STREAMPING, Receiver = stream.receiver, sid = stream.id})
			stream.pinging = true
			stream.timeout = 15
			stream.lastPing = computer.uptime()
		end
	end
end

------------------------------- END STREAMS MODULE -------------------------------

------------------------------- FTP MODULE -------------------------------




------------------------------- END FTP MODULE -------------------------------









return network

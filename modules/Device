local Device = {}
Device.driverList = {
	Default = {Name = "Default", desc = "Default, no special function"};
	Server = {Name = "Server", desc = "Central control server for networked devices"};
	Tablet = {Name = "Tablet", desc = "Remote control terminal", file = "Tablet"};
	Fusion_Reactor = {Name = "Fusion_Reactor", desc = "Used to control the Mekanism Fusion Reactor"};
	Redstone = {Name = "Redstone", desc = "Used to control redstone"};
}

Device.miniAppList = {
	LRelay = {Name = "LRelay", desc = "Relay program for linked cards", file = "LinkedRelay"};
	GCont = {Name = "GCont", desc = "Used to control Stargates which are not connected to a full StattenOS network", file = "GateController"};
}

Device.currentConfig = {
	Name = computer.address():sub(1,8);
	Driver = "Default";
	Settings = {} -- Entry = Name = {Group = "group", Type = "string", Value = "default"}
}

Device.Driver = nil
Device.updateReceived = false
Device.updateFiles = {}
Device.updateDirectories = {}
Device.okToUpdate = false
Device.updating = false

Device.updatePackage = nil

Device.loadConfig = function()
	local str = Packager.getFileString("/config")
	if (not str) then print("'/config' does not exist, creating new configuration file") return end
	Device.currentConfig = serialization.unserialize(str) or Device.currentConfig
	if (not Device.currentConfig.Settings) then Device.currentConfig.Settings = {} end
	return true
end

Device.saveConfig = function()
	local str = serialization.serialize(Device.currentConfig)
	local handle, reason = filesystem.open("/config", "w")
	if (not handle) then
		print("Unable to open file ".."/config".."("..reason..")")
		return false
	end
	filesystem.write(handle, str)
	filesystem.close(handle)
	return true
end

Device.getSetting = function(name)
	if (Device.currentConfig.Settings[name]) then
		return true, Device.currentConfig.Settings[name].Value
	end
	return false, nil
end

-- Returns: 0 = ok, 1 = setting does not exist, 2 = type mismatch
Device.setSetting = function(name, value) then
	if (tonumber(value)) then value = tonumber(value)) end
	if (Device.currentConfig.Settings[name]) then
		if (type(value):lower() == Device.currentConfig.Settings[name].Type:lower()) then
			Device.currentConfig.Settings[name].Value = value
			return 0
		else
			return 2, Device.currentConfig.Settings[name].Type:lower()
		end
	end
	return 1
end

Device.getSettingsList = function()
	local tbl = {}
	for i,p in pairs(Device.currentConfig.Settings) do
		if (not tbl[p.Group]) then tbl[p.Group] = {} end
		table.insert(tbl[p.Group], i)
	end
	return tbl
end


Device.commandListener = function(_, localNetworkCard, remoteAddress, port, distance, packet)
	if (port ~= 0) and (port ~= Enum.Port.Command) and (port ~= Enum.Port.General) then return end
	if (packet.Header == Enum.Header.RUNCOMMAND) then
		if (Commands.busy) then Device.commandBusyResponse(packet) return end
		local cmd = tostring(packet.CommandStr) or ""
		Shell.print("\n&#f32CD32&#"..packet.Sender.."&#fFFFFFF&#"..Shell.prompt.."&#fADD8E6&#"..packet.CommandStr.."&#fFFFFFF&#")
		OS.sleep(0.1)
		local strTbl = text.split(cmd, " ")
		if (not strTbl) then Device.commandFailResponse(packet) return end
		if (#strTbl < 1) then Device.commandFailResponse(packet) return end
		local startText = strTbl[1]
		table.remove(strTbl, 1)
		local newStrTbl = {}
		for i,p in pairs(strTbl) do
			if (p ~= "") and (p ~= " ") and (p ~= nil) then
				table.insert(newStrTbl, p)
			end
		end
		local success, message = pcall(function() Commands.executeCommand(startText, packet, table.unpack(newStrTbl)) end)
		if (not success) then print(message) end
	end
end

Device.commandFailResponse = function(packet)
	local response = newResponse(packet)
	response:sendAck()
	response:sendFailure()
end

Device.commandBusyResponse = function(packet)
	local response = newResponse(packet)
	response:sendAck()
	response:sendBusy()
end

Device.updateListener = function(_, FileName, FilePath) -- FTP event Listener
	if (FileName == "UpdatePackage") then
		Shell.print("Received update package, run 'reboot' to install update and reboot")
		Device.updatePackage = FilePath
	end
end

Device.init = function()
	Device.loadConfig()
	print("Loading Device Driver '"..Device.currentConfig.Driver.."'")
	local driverPath = "/drivers/"..Device.currentConfig.Driver
	if (filesystem.exists(driverPath)) then
		Device.Driver = dofile(driverPath)
		if (Device.Driver) then
			Device.Driver.load(Device.currentConfig)
			Device.Driver.init()
			Device.Driver.registerCommands()
			Device.saveConfig()
		else
			network.registerPingListener()
		end
	else
		network.registerPingListener()
	end
	print("Device Name: "..Device.currentConfig.Name)
	network.registerNetworkListener(Device.commandListener)
	network.ftp.registerFtpListener(Device.updateListener)
	-- set label
	local dProxy = fs.drive.letterToProxy(initDrive)
	dProxy.setLabel(Device.currentConfig.Name)
	-- send notification to server
	network.sendKeepalivePacket()
end






































return Device

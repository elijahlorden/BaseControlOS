function loadfile(file, mode, env)
  local handle, reason = filesystem.open(file)
  if not handle then
    error(reason, 2)
  end
  local buffer = ""
  repeat
    local data, reason = filesystem.read(handle)
    if not data and reason then
      error(reason)
    end
    buffer = buffer .. (data or "")
  until not data
  filesystem.close(handle)
  if mode == nil then mode = "bt" end
  if env == nil then env = _G end
  return load(buffer, "=" .. file)
end

function dofile(file)
  local program, reason = loadfile(file)
  if program then
    local result = table.pack(pcall(program))
    if result[1] then
      return table.unpack(result, 2, result.n)
    else
      error(result[2])
    end
  else
    error(reason)
  end
end

event = event_code()
component_code()
text = text_code()
filesystem = fs_code()
fs = filesystem
keyboard = dofile("Keyboard.lua")
term = terminal_code()

network = dofile("network")
serialization = dofile("serialization")
Enum = dofile("Enum")

event_code, component_code, text_code, fs_code, terminal_code = nil, nil, nil, nil, nil

-- bind GPU

if term.isAvailable() then
  component.gpu.bind(component.screen.address)
  component.gpu.setResolution(component.gpu.getResolution())
  component.gpu.setBackground(0x000000)
  component.gpu.setForeground(0xFFFFFF)
  term.setCursorBlink(true)
end

network.portInit()
print()
print("LinkedRelay Started")

sendToLinkedCards = function(packet)
	local tunnels = component.list("tunnel", true) or {}
	for a,t in tunnels do
		local tc = component.proxy(a)
		tc.send(packet)
	end
end

handleEndpointMessage = function(inpkt)
	local pkt = serialization.unserialize(inpkt)
	if (not pkt) then return end
	
	
	
end

while true do
	_, localNetworkCard, remoteAddress, port, distance, inpkt = event.pull("modem_message")
	--print("message on port "..port)
	if (port == Enum.Port.LinkedCard) then
		
		local sendPort = Enum.Port[desPkt.PortName] or Enum.Port.General
		component.modem.broadcast(sendPort, inpkt)
		
	elseif (port == Enum.Port.SpatialTransfer) then --Messages coming from the rest of the network should be forwarded to the endpoint
		
	end
end




--[[
SPATIAL TRANSFER NETWORK PROTOCOL OUTLINE:
All session state changes and tracking will be performed by the endpoint that initiated the transfer, the second endpoint will act as a slave once the session has started
 -- INITIAL HANDSHAKE --
0.	Sender will not accept a transfer command if it is currently busy
	If Sender does not have at least two times the required power for the transfer, it will not attempt the transfer
1.	A transfer request is invoked on an endpoint (Sender)
	Sender will respond as busy to any requests made until the transfer has been either completed or aborted
2. 	Sender requests information about the second endpoint (Receiver) based on the provided name
3. 	If Receiver responds as busy or the request times out, the transfer is aborted
	If Receiver responds as available, Sender requests a transfer session.
	If Receiver responds as available but does not have a drive, the transfer will be aborted if the sender also does not have a drive.
	If Receiver responds as not having enough power to complete the transfer, the transfer will be aborted.
4.  If Receiver does not acknowledge the new session or fails to respond, the transfer is aborted.
	If Receiver acknowledges the new session, it will respond as busy to any other requests until the session has ended.
	If Receiver acknowledges the new session, it will send a confirmation 
 -- TESSERACT CHANNEL SELECTION --
0.	Both Sender and Receiver discard anything that may currently be in their tesseracts
1. 	If Sender has a previous record of working channels, it will use those, otherwise Sender selects two random channels between 1 and 999
2. 	Sender sets its SEND tesseract to the first channel, and it's RECEIVE tesseract to the second channel
3. 	Sender sends the selected frequencies to Receiver
4. 	Receiver sets its RECEIVE tesseract to the first channel, and its SEND resseract to the second channel
5.	Sender selects a test item, and passes it into its SEND tesseract
6.	Receiver will detect any items in its RECEIVE tesseract, and send them through its SEND tesseract
7.	Sender will detect any items in its RECEIVE tesseract, and compare them to the saved data of the test item
	If the test item fails to be returned to Sender, or if Sender receives an item that does not match the test item, it jumps back to step 1
	If this process fails 10 times, the session is ended and the transfer is aborted
8.	Sender will attempt to return the test item to its buffer, and if not succsessful will move it into its trashcan
 -- SPATIAL TRANSFER --
1.	If Sender has a drive, it will pulse its Spatial I/O port
2.	If Receiver has a drive, it will move it into its SEND tesseract.  If Sender does not have a drive, it will move Receivers drive into its Spatial I/O port and pulse it.
	If Sender does not have a drive and does not receive Receivers drive, the transfer is aborted
3.	Sender moves its drive into its SEND tesseract, and (if two drives ARE present, and if Sender receives it) moves Receivers drive into its Spatial I/O port.  Sender will also discard any items that are not Receivers drive (this should not happen, but this prevents the network from becoming clogged if the current tesseract frequencies become active elsewhere)
4.	Receiver will wait for Senders drive, while discarding any items that are not Senders drive (this should not happen, but this prevents the network from becoming clogged if the current tesseract frequencies become active elsewhere)
5.	Receiver will pulse its Spatial I/O port
6.	Receiver sends a confirmation message to Sender, and the transfer is completed
	If Receiver fails to send a confirmation message, Sender will consider the transfer failed
--]]










local Server = {}

Server.deviceList = {[network.acceptedServerName] = {Name = network.acceptedServerName, Type = "Server", Address = component.modem.address, Pinged = true}} -- Name = {Name = name, Type = driverName, ConnectionTime = 0, Address = address}

Server.unauthorizedDevices = {}

Server.lastPing = 0
Server.pingTimeout = 5

Server.connectBeep = 1500
Server.disconnectBeep = 300

Server.init = function()
	Server.pingDevices()
	event.timer(20, Server.pingDevices, math.huge)
	event.timer(180, function() Server.sendDeviceList() end, math.huge)
	network.registerNetworkListener(Server.networkListener)
	event.listen(Enum.Event.UNAUTHNETWORKSIGNAL,Server.unauthTrafficListener)
	--event.listen("component_added", Server.diskAddedEvent)
	--event.listen("component_removed", onComponentRemoved)
	Security.serverInit()
end

Server.load = function(config)
	if (not config.GateRegistry) then config.GateRegistry = {} end
	if (not config.AuthorizedDevices) then config.AuthorizedDevices = {} end -- DeviceAddr = {DeviceAddr, DeviceName}
	config.Name = network.acceptedServerName
	network.deviceList = config.AuthorizedDevices
end

Server.setup = function()
	
end


Server.powerOff = function()

end

Server.registerCommands = function()
	--Commands.registerCommand("listDevices", Server.listDeviceCmd , "Lists currently connected devices, add TypeFilter to filter devices by type", "[TypeFilter]")
	Commands.registerCommand("sendUpdate", Server.updateCmd , "Package OS currently installed on Server and send it to networked devices.", "[DeviceName]")
	Commands.registerCommand("ping", Server.pingCmd , "Ping network for active devices", "")
	Commands.registerCommand("listGroups", Server.listGroupsCmd , "List all security groups", "")
	Commands.registerCommand("listUnauthorizedDevices", Server.listUnahthDevicesCmd , "List unauthorized devices", "[page]")
	Commands.registerCommand("listAuthorizedDevices", Server.listAuthedDevicesCmd , "List unauthorized devices", "[page]")
	Commands.registerCommand("authorizeDevice", Server.authDeviceCmd , "Authorize a currently unauthorized device", "device")
	Commands.registerCommand("getGroupAccessLevel", Server.getGroupAccessLevelCmd , "View the access level of a group", "group")
	Commands.registerCommand("listGroupsAtAccessLevel", Server.listGroupsAtAccessLevelCmd , "List groups at/above/below an access level", "[>,<] level")
end

Server.authDeviceCmd = function(response, n)
	local d = Server.unauthorizedDevices[tonumber(n)]
	if (not d) then response:print("Unauthorized Device "..n.." not found") response:flush() response:sendFailure() return true end
	local ex = false
	for i,p in pairs(Device.currentConfig.AuthorizedDevices) do
		if (p == ex) then ex = true break end
	end
	if (ex) then
		response:print("Device is already authorized")
	else
		table.insert(Device.currentConfig.AuthorizedDevices,d)
		table.remove(Server.unauthorizedDevices,n)
		network.deviceList = Device.currentConfig.AuthorizedDevices
		response:print("Device "..d.." is now authorized to access the network")
		Device.saveConfig()
	end
	return true
end

Server.unauthDeviceCmd = function(response, n)
	local d = Server.unauthorizedDevices[tonumber(n)]
	if (not d) then response:print("Unauthorized Device "..n.." not found") response:flush() response:sendFailure() return true end
	local ex = false
	for i,p in pairs(Device.currentConfig.AuthorizedDevices) do
		if (p == ex) then ex = true break end
	end
	if (not ex) then
		response:print("Device is already unauthorized or does not exist")
	else
		table.remove(Device.currentConfig.AuthorizedDevices,n)
		network.deviceList = Device.currentConfig.AuthorizedDevices
		response:print("Device "..d.." is no longer authorized to access the network")
		Device.saveConfig()
	end
	return true
end

Server.listUnahthDevicesCmd = function(response, page)
	page = math.max(tonumber(page or 1),1)
	if (not page) then return false end
	local list = Server.unauthorizedDevices
	local st = (10*(page-1))+1
	local sp = (#list >= st+10) and (st+10) or #list
	if (st > #list) then response:print("Page "..page.." does not exist") response:flush() response:sendFailure() return true end
	response:print("Unauthorized Devices page "..page.."/"..(math.floor(#list/10)+1))
	for i=st,sp do
		response:print("["..i.."]: "..list[i])
	end
	return true
end

Server.listAuthedDevicesCmd = function(response, page)
	page = math.max(tonumber(page or 1),1)
	if (not page) then return false end
	local list = Device.currentConfig.AuthorizedDevices
	local st = (10*(page-1))+1
	local sp = (#list >= st+10) and (st+10) or #list
	if (st > #list) then response:print("Page "..page.." does not exist") response:flush() response:sendFailure() return true end
	response:print("Authorized Devices page "..page.."/"..(math.floor(#list/10)+1))
	for i=st,sp do
		response:print("["..i.."]: "..list[i])
	end
	return true
end

Server.listGroupsCmd = function(response)
	local groups = mapToKeyPair(Security.loadedData.Groups)
	local str = "&#f00FF00&#"
	for i,p in pairs(groups) do
		if (i ~= #groups) then
			str = str..p[1]..", "
		else
			str = str..p[1]
		end
	end
	response:print(str)
	return true
end

Server.listGroupsAtAccessLevelCmd = function(response, a1, a2)
	local str = "&#f00FF00&#"
	local groups = mapToKeyPair(Security.loadedData.Groups)
	local sortFunc, num
	if (a1 and a2) and (type(a1) == "string") and (tonumber(a2)) then
		num = tonumber(a2)
		if (a1:lower() == ">") then
			sortFunc = function(x,y) return x > y end
		elseif (a1:lower() == "<") then
			sortFunc = function(x,y) return x < y end
		else
			return false
		end
	elseif (tonumber(a1)) and (not a2) then
		num = tonumber(a1)
		sortFunc = function(x,y) return x == y end
	else
		return false
	end
	for i,p in pairs(groups) do
		if (sortFunc(p[2], num)) then
			str = str..p[1]..", "
		end
	end
	str = str:sub(1,str:len()-2)
	response:print(str)
	return true
end

Server.getGroupAccessLevelCmd = function(response, group)
	local tGroup = Security.loadedData.Groups[group]
	if (not tGroup) then response:print("Group does not exist") response:flush() response:sendFailure() return true end
	response:print("&#f00FF00&#"..group.."&#fFFFFFF&# has access level &#fFFFF00&#"..tGroup[2])
	return true
end

Server.setGroupAccessLevelCmd = function(response, group, newLevel)
	local tGroup = Security.loadedData.Groups[group]
	if (not tGroup) or (not tonumber(newLevel)) then response:print("Group does not exist") response:flush() response:sendFailure() return true end
	tGroup[2] = tonumber(newLevel)
	response:print("&#f00FF00&#"..group.."&#fFFFFFF&# now has access level &#fFFFF00&#"..tGroup[2])
	return true
end

Server.listUsersInGroupCmd = function(response, page)
	
end

Server.listUsersCmd = function(response, page)
	
end

Server.addGroupCmd = function(response, name, level)
	
end

Server.removeGroupCmd = function(response, name)
	
end

Server.addUserCmd = function(response, name, group)

end

Server.removeUserCmd = function(response, id)
	
end

Server.setUserGroupCmd = function(response, id, group)
	
end

Server.formatUsrDskCmd = function(response, usrid, disk)
	
end

Server.rotateUsrCodesCmd = function(response, usrid)
	
end

Server.pingCmd = function(response)
	response:print("Pinging network...")
	Server.pingDevices()
	return true, response
end

Server.updateCmd = function(response, deviceName)
	local cmdReceiver = deviceName or "All"
	response:print("Sending update packages to "..cmdReceiver)
	response:flush()
	local packagedOS = Packager.packageIntoTable()
	response:print("Serializing packaged OS")
	response:flush()
	OS.sleep(0.1)
	local serializedOS = JSON.encode(packagedOS)
	response:print("Writing packaged OS to temporary file")
	local tmpProxy = component.proxy(computer.getBootAddress())
	if (tmpProxy.exists("/tmp/out_UpdatePackage")) then tmpProxy.remove("/tmp/out_UpdatePackage") end
	local handle, reason = tmpProxy.open("/tmp/out_UpdatePackage", "w")
	if (not handle) then response:print("Error opening file ("..reason..")") return end
	tmpProxy.write(handle, serializedOS)
	tmpProxy.close(handle)
	response:print("Sending file via FTP")
	response:print(tmpProxy.size("/tmp/out_UpdatePackage").."b")
	response:flush()
	network.ftp.sendFile(tmpProxy, "/tmp/out_UpdatePackage", "UpdatePackage", cmdReceiver)
	response:print("Update distributed")
	return true
end

Server.listDeviceCmd = function(response, typeFilter)
	local filter = typeFilter or ""
	local str = ""
	response:print("Format: &#fFFA500&#{DeviceName : DeviceType}&#fFFFFFF&#")
	for i,p in pairs(Server.deviceList) do
		if (string.find(p.Type, filter)) then
			str = str.."{"..p.Name.." : "..p.Type.."} "
		end
	end
	response:print("&#fFFA500&#"..str.."&#fFFFFFF&#")
	response:flush()
	return true
end

Server.isDeviceAuthorized = function(address)
	
end

Server.networkListener = function(_, localNetworkCard, remoteAddress, port, distance, packet)
	if (port ~= 0) and (port ~= Enum.Port.Keepalive) and (port ~= Enum.Port.Stargate) and (port ~= Enum.Port.General) then return end
	if (packet.Header ~= Enum.Header.SHUTDOWN) then
		if (Server.deviceList[packet.Sender] ~= nil) then
			Server.deviceList[packet.Sender].Pinged = true
			Server.deviceList[packet.Sender].Address = remoteAddress
			network.deviceList = Device.currentConfig.AuthorizedDevices
			--Shell.print(packet.Sender.." Responded to network ping")
		else
			Server.deviceList[packet.Sender] = {Name = packet.Sender, Type = packet.SenderType, Address = remoteAddress, Pinged = true}
			network.deviceList = Device.currentConfig.AuthorizedDevices
			Server.notifyOfNewDevice(Server.deviceList[packet.Sender])
			Shell.print("Network Device "..packet.Sender.." ("..packet.SenderType..") Connected")
			computer.beep(Server.connectBeep)
			Server.sendDeviceList(packet.Sender)
		end
	end

	if (packet.Header == Enum.Header.SHUTDOWN) then
		if (Server.deviceList[packet.Sender] ~= nil) then
			Server.deviceList[packet.Sender] = nil
			network.deviceList = Device.currentConfig.AuthorizedDevices
			Shell.print(packet.Sender.." Disconnected (Reason: Shutting Down)")
			computer.beep(Server.disconnectBeep)
		end
	elseif (packet.Header == Enum.Header.FETCHGATEREGISTRY) then
		if (not packet.Sender) then return end
		Shell.print("GateRegistry Fetch Request")
		local outPkt = {Header = "GateRegistryFetched", Registry = Device.currentConfig.GateRegistry, Receiver = packet.Sender}
		network.sendPacket(Enum.Port.StargateResponse, outPkt, false)
	elseif (packet.Header == Enum.Header.REGISTERGATE) then
		if (not packet.GateName) or (not packet.GateAddress) then return end
		Device.currentConfig.GateRegistry[packet.GateName] = packet.GateAddress
		Shell.print("Gate "..packet.GateName.." Registered to address "..packet.GateAddress)
		Server.sendGateRegistryBroadcast()
		Device.saveConfig()
	elseif (packet.Header == Enum.Header.UNREGISTERGATE) then
		if (not packet.GateName) then return end
		Device.currentConfig.GateRegistry[packet.GateName] = nil
		Shell.print("Gate "..packet.GateName.." Unregistered")
		Server.sendGateRegistryBroadcast()
		Device.saveConfig()
	end
end

Server.sendGateRegistryBroadcast = function()
	local outPkt = {Header = Enum.Header.GATEREGISTRYBROADCAST, Registry = Device.currentConfig.GateRegistry}
	network.sendPacket(Enum.Port.StargateResponse, outPkt, false)
	Shell.print("Broadcasted GateRegistry update")
end

Server.pingDevices = function()
	local outPkt = {Header = Enum.Header.SERVERPING, Registry = Device.currentConfig.GateRegistry}
	network.sendPacket(Enum.Port.Keepalive, outPkt, false)
	for i,p in pairs(Server.deviceList) do
		p.Pinged = false
	end
	--Shell.print("Pinging network...")
	event.timer(Server.pingTimeout, function()
		for i,p in pairs(Server.deviceList) do
			if (not p.Pinged) and (p.Name ~= network.acceptedServerName) then
				Shell.print(p.Name.." Disconnected (Reason: Timed Out)")
				computer.beep(Server.disconnectBeep)
				Server.notifyOfDisconnect(Server.deviceList[i])
				Server.deviceList[i] = nil
			end
		end
	end)
end

Server.sendDeviceList = function(receiver) -- Send the device list in chunks, in order to avoid locking up the receiving computers
	local dpp = 10
	local rstpkt = {Header = Enum.Header.RSTLOCALDEVICELIST, Receiver = (receiver or "All")}
	network.sendPacket(Enum.Port.ServerInfo, rstpkt, false)
	local packet = {Header = Enum.Header.SERVERDEVICELIST, List = {}, Receiver = (receiver or "All")}
	for i,p in pairs(Server.deviceList) do
		packet.List[i] = p
		if (#mapToKeyPair(packet.List) >= dpp) then
			network.sendPacket(Enum.Port.ServerInfo, packet, false)
			packet.List = {}
		end
	end
	if (#mapToKeyPair(packet.List) > 0) then
		network.sendPacket(Enum.Port.ServerInfo, packet, false)
	end
end

Server.notifyOfNewDevice = function(device)
	local outPkt = {Header = Enum.Header.NEWDEVICE, NewDevice = device}
	network.sendPacket(Enum.Port.ServerInfo, outPkt, false)
end

Server.notifyOfDisconnect = function(device)
	local outPkt = {Header = Enum.Header.DEVICEDISCONNECT, DeviceName = device.Name}
	network.sendPacket(Enum.Port.ServerInfo, outPkt, false)
end







Server.unauthTrafficListener = function(_, address)
	local ex = false
	for i,p in pairs(Server.unauthorizedDevices) do
		if (p == address) then ex = true break end
	end
	if (not ex) then
		table.insert(Server.unauthorizedDevices, address)
		Shell.print("New unauthorized device detected, assigned to "..#Server.unauthorizedDevices)
	end
end

























return Server

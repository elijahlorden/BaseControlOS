local Server = {}

Server.deviceList = {[network.acceptedServerName] = {Name = network.acceptedServerName, Type = "Server", ConnectionTime = 0, Address = component.modem.address}} -- Name = {Name = name, Type = driverName, ConnectionTime = 0, Address = address}


Server.tickInterval = 0.1
Server.deviceTimeout = 20

Server.connectBeep = 1500
Server.disconnectBeep = 300

Server.init = function()
	event.timer(Server.tickInterval, Server.tickConnections, math.huge)
	network.registerNetworkListener(Server.networkListener)
end

Server.load = function(config)
	if (not config.GateRegistry) then config.GateRegistry = {} end
	config.Name = network.acceptedServerName
end

Server.setup = function()
	
end


Server.powerOff = function()
	
end

Server.registerCommands = function()
	Commands.registerCommand("listDevices", Server.listDeviceCmd , "Lists currently connected devices, add TypeFilter to filter devices by type", "[TypeFilter]")
	Commands.registerCommand("sendUpdate", Server.updateCmd , "Package OS currently installed on Server and send it to networked devices.", "[DeviceName]")
end

Server.updateCmd = function(deviceName)
	local response = newResponse()
	local cmdReceiver = deviceName or "All"
	print("Sending update packages to "..cmdReceiver)
	response.print("Sending update packages to "..cmdReceiver)
	local packagedOS = Packager.packageIntoTable()
	print("Serializing packaged OS")
	response.print("Serializing packaged OS")
	OS.sleep(0.1)
	local serializedOS = JSON.encode(packagedOS)
	print("Writing packaged OS to temporary file")
	response.print("Writing packaged OS to temporary file")
	local tmpProxy = component.proxy(computer.getBootAddress())
	if (tmpProxy.exists("/tmp/out_UpdatePackage")) then tmpProxy.remove("/tmp/out_UpdatePackage") end
	local handle, reason = tmpProxy.open("/tmp/out_UpdatePackage", "w")
	if (not handle) then print("Error opening file ("..reason..")") return end
	print(serializedOS:len().." Characters")
	tmpProxy.write(handle, serializedOS)
	tmpProxy.close(handle)
	print("Sending file via FTP")
	print(tmpProxy.size("/tmp/out_UpdatePackage").."b")
	response.print("Sending file via FTP")
	network.ftp.sendFile(tmpProxy, "/tmp/out_UpdatePackage", "UpdatePackage", cmdReceiver)
	print("Update distributed")
	response.print("Update distributed")
	return true, response
end

Server.listDeviceCmd = function(typeFilter)
	local filter = typeFilter or ""
	local response = newResponse()
	local str = ""
	for i,p in pairs(Server.deviceList) do
		if (string.find(p.Type, filter)) then
			str = str..p.Name.." "..p.Type.." "..p.Address.."\n"
		end
	end
	printPaged(str)
	response.printPaged(str)
	return true, response
end

Server.networkListener = function(_, localNetworkCard, remoteAddress, port, distance, inpkt)
	if (not port) then return end
	if (port ~= 0) and (port ~= network.Ports.Keepalive) and (port ~= network.Ports.Stargate) and (port ~= network.Ports.General) then return end
	if (not inpkt) or (type(inpkt):lower() ~= "string") then return end
	local packet = serialization.unserialize(inpkt)
	if (not packet) then return end
	if (not packet.Header) or (not packet.Sender) or (not packet.SenderType) then return end
	if (packet.Header ~= "Shutdown") then
		if (Server.deviceList[packet.Sender] ~= nil) then
			Server.deviceList[packet.Sender].ConnectionTime = 0
			Server.deviceList[packet.Sender].Address = remoteAddress
		else
			Server.deviceList[packet.Sender] = {Name = packet.Sender, Type = packet.SenderType, ConnectionTime = 0, Address = remoteAddress}
			Shell.print("Network Device "..packet.Sender.." ("..packet.SenderType..") Connected")
			computer.beep(Server.connectBeep)
		end
	end
	
	if (packet.Header == "Shutdown") then
		if (Server.deviceList[packet.Sender] ~= nil) then
			Server.deviceList[packet.Sender] = nil
			Shell.print(packet.Sender.." Disconnected")
			computer.beep(Server.disconnectBeep)
		end
	elseif (packet.Header == "FetchGateRegistry") then
		if (not packet.Sender) then return end
		Shell.print("GateRegistry Fetch Request")
		local outPkt = {Header = "GateRegistryFetched", Registry = Device.currentConfig.GateRegistry, Receiver = packet.Sender}
		network.sendPacket(network.Ports.StargateResponse, outPkt, false)
	elseif (packet.Header == "RegisterGate") then
		if (not packet.GateName) or (not packet.GateAddress) then return end
		Device.currentConfig.GateRegistry[packet.GateName] = packet.GateAddress
		Shell.print("Gate "..packet.GateName.." Registered to address "..packet.GateAddress)
		Server.sendGateRegistryBroadcast()
		Device.saveConfig()
	elseif (packet.Header == "UnregisterGate") then
		if (not packet.GateName) then return end
		Device.currentConfig.GateRegistry[packet.GateName] = nil
		Shell.print("Gate "..packet.GateName.." Unregistered")
		Server.sendGateRegistryBroadcast()
		Device.saveConfig()
	end
end

Server.sendGateRegistryBroadcast = function()
	local outPkt = {Header = "GateRegistryBroadcast", Registry = Device.currentConfig.GateRegistry}
	network.sendPacket(network.Ports.StargateResponse, outPkt, false)
	Shell.print("Broadcasted GateRegistry update")
end

Server.tickConnections = function()
	for i,d in pairs(Server.deviceList) do
		if (i ~= network.acceptedServerName) then
			d.ConnectionTime = d.ConnectionTime + Server.tickInterval
			--Shell.print(d.Name.." : "..d.ConnectionTime)
			if (d.ConnectionTime > 20) then Server.deviceList[i] = nil Shell.print(i.." Disconnected") computer.beep(Server.disconnectBeep) end
		end
	end
end





























return Server